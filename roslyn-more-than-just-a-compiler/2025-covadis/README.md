# Roslyn: Meer Dan Alleen een Compiler

## Introductie (5 min.)

- Roslyn is de code naam voor het .NET Compiler Platform
- Oorspronkelijke C# compiler was geschreven in C++
- Doel van Roslyn:
  - EÃ©n enkele plaats om C# code te parsen
  - Open voor gebruik externe partijen (en open-source)
  - Verbeteren onderhoudbaarheid en verhoogde productiviteit (sneller nieuwe features)
  - Dogfooding (gebruik C# in de C# compiler)

## Opzet compiler

Fases:

1. Parse fase: parse broncode naar AST
2. Declaration fase: symbols en metadata
3. Bind fase: verbind symbolen aan identifiers
4. Emit fase: genereer IL code

Diagram: https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/compiler-api-model#compiler-pipeline-functional-areas

## Demo 1: scripting (3 min.)

Doel: demonstreren van Roslyn scripting API's

Demo:

- Toon package
- Run code: `CSharpScript.RunAsync`
- Print return value: `state.ReturnValue`
- Run code vanuit state: `state.ContinueWithAsync`

## Demo 2: analyseer code (20 min.)

Doel: introductie van Roslyn's API voor het werken met C# code

Demo:

- Installeer package: `Microsoft.CodeAnalysis.CSharp`
- Parse C# code: `CSharpSyntaxTree.ParseText`
- Toon AST: Syntax Visualizer en https://sharplab.io/
- Verschil tussen `SyntaxNode` en `SyntaxToken`
  1. Gebruik file-scoped namespace
  2. Gebruik exponent notatie
  3. Gebruik `AddSeconds`

## Demo 3: herschrijven code (10 min.)

Doel: demonstreren van Roslyn's API voor het herschrijven van C# code

Demo:

- Wegschrijven tree: `root.ToFullString()`
- Normaliseren whitespace: `root.NormalizeWhitespace()`
- Immutable tree `root.RemoveNodes(root.DescendantNodes().OfType<EmptyStatementSyntax>(), SyntaxRemoveOptions.AddElasticMarker)`
- Gebruik van `SyntaxRewriter` om nodes te herschrijven
  1. Verwijder empty statements
  2. Gebruik exponent notatie
  - Gebruik `SyntaxFactory.Literal` voor nieuw token

## Demo 4: solution-wide herschrijven (8 min.)

Doel: demonstreren van Roslyn's API voor het herschrijven van code in een solution

Demo:

- Laad solution: `MSBuildWorkspace.Create()`
- Vind symbol voor extern package: `compilation.GetTypeByMetadataName("Xunit.FactAttribute")`
- Gebruik van `DocumentEditor`
- Symbol informatie voor methode: `SemanticModel.GetDeclaredSymbol(methodDeclarationSyntax)`
- Hernoem methode via `Renamer.RenameSymbolAsync`
- Laat zien dat solution/project/document immutable zijn

## Demo 5: analyzer

Doel: laat zien wat analyzers zijn en hoe je ze kunt gebruiken

Demo:

1. Exponent notatie analyzer
   - Laat tests zien
2. Exponent notatie fixer
   - Gebruik van: `getInnermostNodeForTie: true`

## Demo 6: genereer code

Doel: demonstreren van Roslyn code generatie API's

Demo:

- Gebruik van Roslyn Quoter website (https://roslynquoter.azurewebsites.net/)
- Gebruik `using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;`
- Bij fout niet meer kunnen compileren
- Gebruik `.NormalizeWhitespace()`
- Toevoegen van `// <auto-generated>` comment: `.WithLeadingTrivia(Comment("// <auto-generated>"))`

## Demo 7: source generator

Doel: demonstreren van Roslyn source generator API's

Demo:

- Verzamel additional texts
- Add source: `context.AddSource($"{className}.g.cs", code.ToFullString());`

## Demo 8: in-memory compilatie (3 min.)

Doel: laat zien hoe je code in-memory kunt compileren met Roslyn

Demo:

- Emit IL code: `compilation.Emit(stream)`
- Laad assembly: `var assembly = Assembly.Load(stream.ToArray())`
- Maak type aan: `var movieType = assembly.GetType("Movie")`
- Maak instantie aan: `Activator.CreateInstance(movieType, "Inception", 2010)`
